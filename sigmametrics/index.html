<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Demo Σ-Metrics</title>
  <!-- Plotly para gráficos -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <!-- MathJax para fórmulas LaTeX -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; }
    h1 { color: #2c3e50; }
    #grafico { width: 100%; max-width: 800px; height: 500px; }
    #metricas { margin-top: 20px; font-size: 18px; }
    .valor { font-weight: bold; color: #27ae60; }
  </style>
</head>
<body>
  <h1>Demo Interactivo — Σ-Metrics</h1>
  <p><b>ES:</b> Comparación entre señal causal (Q-driven) y ruido entrópico (φ-driven), con cálculo de métricas Σ.</p>
  <p><b>EN:</b> Comparison between causal signal (Q-driven) and entropic noise (φ-driven), with Σ metrics calculation.</p>

  <div id="grafico"></div>
  <div id="metricas"></div>

  <h2>Formulación Matemática</h2>
  <p>RMSE:</p>
  <p>\\( RMSE = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (Q_i - \\phi_i)^2} \\)</p>

  <p>Coeficiente de coherencia κΣ:</p>
  <p>\\( \\kappa_{\\Sigma} = \\frac{\\text{Cov}(Q, \\phi)}{\\sigma_Q \\cdot \\sigma_\\phi} \\)</p>

  <script>
    // Datos simulados
    const tiempo = Array.from({length: 50}, (_, i) => i);
    const causal = tiempo.map(t => Math.sin(t/5) + (Math.random()*0.2)); // señal coherente
    const ruido = tiempo.map(t => Math.random()*2 - 1); // ruido entrópico

    // Función RMSE
    function calcularRMSE(arr1, arr2) {
      const n = arr1.length;
      const sum = arr1.reduce((acc, val, i) => acc + Math.pow(val - arr2[i], 2), 0);
      return Math.sqrt(sum / n);
    }

    // Función κΣ (coeficiente de coherencia)
    function calcularKappa(arr1, arr2) {
      const n = arr1.length;
      const mean1 = arr1.reduce((a,b)=>a+b,0)/n;
      const mean2 = arr2.reduce((a,b)=>a+b,0)/n;
      const cov = arr1.reduce((acc,val,i)=>acc+(val-mean1)*(arr2[i]-mean2),0)/n;
      const std1 = Math.sqrt(arr1.reduce((acc,val)=>acc+Math.pow(val-mean1,2),0)/n);
      const std2 = Math.sqrt(arr2.reduce((acc,val)=>acc+Math.pow(val-mean2,2),0)/n);
      return cov/(std1*std2);
    }

    const rmse = calcularRMSE(causal, ruido);
    const kappa = calcularKappa(causal, ruido);

    // Gráfico
    const trace1 = { x: tiempo, y: causal, mode: 'lines+markers', name: 'Q-driven', line: {color: 'blue'} };
    const trace2 = { x: tiempo, y: ruido, mode: 'lines+markers', name: 'φ-driven', line: {color: 'red'} };
    const layout = { title: 'Σ-Metrics Demo', xaxis: {title: 'Tiempo'}, yaxis: {title: 'Valor'}, legend: {orientation: 'h'} };

    Plotly.newPlot('grafico', [trace1, trace2], layout);

    // Mostrar métricas
    document.getElementById("metricas").innerHTML = `
      <p>RMSE = <span class="valor">${rmse.toFixed(3)}</span></p>
      <p>κΣ = <span class="valor">${kappa.toFixed(3)}</span></p>
    `;
  </script>
</body>
</html>
